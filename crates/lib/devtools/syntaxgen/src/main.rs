pub mod input;
pub mod kinds;
pub mod nodes;
pub mod sourcegen;
pub mod tokens;

use crate::nodes::generate_nodes;
use sourcegen::normalize_newlines;
use std::{fs, path::Path};
use tracing_subscriber::{EnvFilter, FmtSubscriber};
use ungrammar::Grammar;
use xshell::{cmd, Shell};
use {
    input::STARLARK_KINDS_SRC,
    kinds::generate_kinds,
    sourcegen::{lower, GeneratorKind},
    tokens::generate_tokens,
};

/// The **Starlark grammar** is specified in the **ungrammar** format
const STARLARK_UNGRAMMAR: &str = "grammar/starlark.ungram";

/// The **generated syntax kinds** for the **Starlark language** from
/// `starlark.ungram`
const STARLARK_KINDS: &str = "crates/lib/skylark/sky_syntax/src/ast/generated/kinds.rs";

/// The **generated syntax tokens** for the **Starlark language**
/// from `starlark.ungram`
const STARLARK_TOKENS: &str = "crates/lib/skylark/sky_syntax/src/ast/generated/tokens.rs";

/// The **generated syntax nodes** for the **Starlark language** from
/// `starlark.ungram`
const STARLARK_NODES: &str = "crates/lib/skylark/sky_syntax/src/ast/generated/nodes.rs";

/// Handles the **generation process** for the `SyntaxKind`, `SyntaxNode`, and
/// `SyntaxToken` **data structures** which are used to represent the **syntax
/// trees** of the **language**, based on the **grammar** specified in
/// `starlark.ungram`.
fn main() {
    init_logging(); // Enable for debugging, but otherwise disable as messes with `rust-analyzer`'s logging

    tracing::info!("Parsing {}...", STARLARK_UNGRAMMAR);
    let grammar = include_str!("grammar/starlark.ungram")
        .parse::<Grammar>()
        .expect("Unable to parse `starlark.ungram`");
    tracing::info!("Parsed {}", STARLARK_UNGRAMMAR);

    tracing::info!("Lowering grammar from {}...", STARLARK_UNGRAMMAR);
    let ast = lower(&grammar);

    tracing::debug!("AST: {:#?}", ast);
    tracing::info!("Lowered grammar from {}", STARLARK_UNGRAMMAR);

    tracing::info!("Beginning codegen process. Generating syntax kinds, tokens, and nodes...");

    tracing::info!("Generating syntax kinds...");
    let ast_kinds = generate_kinds(&STARLARK_KINDS_SRC);
    tracing::info!("Generated syntax kinds");

    tracing::info!(
        "Ensuring file contents are up-to-date for {}...",
        STARLARK_KINDS
    );
    ensure_file_contents(STARLARK_KINDS, &ast_kinds);
    tracing::info!("File contents are up-to-date for {}", STARLARK_KINDS);

    tracing::info!("Generating syntax tokens...");
    let ast_tokens = generate_tokens(&ast);
    tracing::info!("Generated syntax tokens");

    tracing::info!(
        "Ensuring file contents are up-to-date for {}...",
        STARLARK_TOKENS
    );
    ensure_file_contents(STARLARK_TOKENS, &ast_tokens);
    tracing::info!("File contents are up-to-date for {}", STARLARK_TOKENS);

    tracing::info!("Generating syntax nodes...");
    let ast_nodes = generate_nodes(STARLARK_KINDS_SRC, &ast);
    tracing::info!("Generated syntax nodes");

    tracing::info!(
        "Ensuring file contents are up-to-date for {}...",
        STARLARK_NODES
    );
    ensure_file_contents(STARLARK_NODES, &ast_nodes);
    tracing::info!("File contents are up-to-date for {}", STARLARK_NODES);

    tracing::info!("Codegen process complete");
}

/// Mutates `text` in place, adding a preamble to the top of the file.
///
/// The preamble is a comment block containing a warning not to edit the file by
/// hand, and a link to the source of the file.
///
/// The `gen_kind` parameter is used to determine the contents of the preamble.
pub fn add_preamble(mut text: String, gen_kind: GeneratorKind) -> String {
    let generated_note = format!(
        "//! Generated by `syntaxgen`, do not edit by hand.\n//!\n//! To regenerate this file, \
         run `buck2 run //:syntaxgen`.\n//!\n//! Source files \
         relevant to code generation for this file include:\n//! `{}`.",
        gen_kind.relevant_sources(),
    );

    let preamble = format!(
        "{}\n//!\n{}\n\n",
        generated_note,
        gen_kind.mod_doc_comment()
    );

    text.insert_str(0, &preamble);
    text
}

fn ensure_file_contents(file_path: &str, contents: &str) {
    if let Ok(existing_contents) = fs::read_to_string(file_path) {
        if normalize_newlines(&existing_contents) == normalize_newlines(contents) {
            return;
        }
    }

    tracing::warn!("{} is not up to date, updating", file_path);

    let file = Path::new(file_path);
    if let Some(parent) = file.parent() {
        let _ = fs::create_dir_all(parent);
    }

    fs::write(file, contents).expect("Failed to write file");
    tracing::error!("{} was not up to date and has been updated", file_path);
    panic!("Please re-run to pick up the changes");
}

fn reformat(text: String) -> String {
    let sh = Shell::new().expect("Failed to create shell for rustfmt");

    let mut stdout = cmd!(sh, "rustup run stable rustfmt --config fn_single_line=true")
        .stdin(text)
        .read()
        .expect("Failed to run rustfmt");

    if !stdout.ends_with('\n') {
        stdout.push('\n');
    }
    stdout
}

fn init_logging() {
    // Create a subscriber with a filter that accepts all events.
    let subscriber = FmtSubscriber::builder()
        .with_env_filter(EnvFilter::from_default_env())
        .with_ansi(true)
        .with_max_level(tracing::Level::DEBUG)
        .with_line_number(true)
        .without_time() // turn off timestamps
        .finish();

    // Set the subscriber as the default.
    tracing::subscriber::set_global_default(subscriber).expect("failed to set subscriber");
}
