//! Generated by `syntaxgen`, do not edit by hand.
//!
//! To regenerate this file, run `buck2 run //:syntaxgen`.
//!
//! Source files relevant to code generation for this file include:
//! `syntaxgen/nodes.rs`,
//! `syntaxgen/input.rs`,
//! `syntaxgen/sourcegen.rs`.
//!
//! Provides a set of various nodes in the AST (Abstract Syntax Tree) and their corresponding behavior.
//! The purpose of these nodes is to facilitate easier navigation and manipulation of the AST
//! by providing a set of methods to access various tokens and related nodes.
//!
//! Each node contains a `syntax` field representing the syntax node and provides methods to access
//! various tokens and related nodes.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};
#[doc = "Node defs"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct File {
    pub(crate) syntax: SyntaxNode,
}
impl File {
    pub fn statements(&self) -> AstChildren<Statement> {
        support::children(&self.syntax)
    }
    pub fn eof_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![eof])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefStmt {
    pub(crate) syntax: SyntaxNode,
}
impl DefStmt {
    pub fn def_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![def])
    }
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn parameters(&self) -> Option<Parameters> {
        support::child(&self.syntax)
    }
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn suite(&self) -> Option<Suite> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfStmt {
    pub(crate) syntax: SyntaxNode,
}
impl IfStmt {
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn suite(&self) -> Option<Suite> {
        support::child(&self.syntax)
    }
    pub fn elif_clauseses(&self) -> AstChildren<ElifClauses> {
        support::children(&self.syntax)
    }
    pub fn else_clause(&self) -> Option<ElseClause> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ForStmt {
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn loop_variables(&self) -> Option<LoopVariables> {
        support::child(&self.syntax)
    }
    pub fn in_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![in])
    }
    pub fn expression(&self) -> Option<Expression> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn suite(&self) -> Option<Suite> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SimpleStmt {
    pub(crate) syntax: SyntaxNode,
}
impl SimpleStmt {
    pub fn small_stmts(&self) -> AstChildren<SmallStmt> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Parameters {
    pub(crate) syntax: SyntaxNode,
}
impl Parameters {
    pub fn parameter(&self) -> Option<Parameter> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Suite {
    pub(crate) syntax: SyntaxNode,
}
impl Suite {
    pub fn newline_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![newline])
    }
    pub fn indent_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![indent])
    }
    pub fn statements(&self) -> AstChildren<Statement> {
        support::children(&self.syntax)
    }
    pub fn outdent_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![outdent])
    }
    pub fn simple_stmt(&self) -> Option<SimpleStmt> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Parameter {
    pub(crate) syntax: SyntaxNode,
}
impl Parameter {
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
    pub fn starstar_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![**])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ElifClauses {
    pub(crate) syntax: SyntaxNode,
}
impl ElifClauses {
    pub fn elif_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![elif])
    }
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn suite(&self) -> Option<Suite> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ElseClause {
    pub(crate) syntax: SyntaxNode,
}
impl ElseClause {
    pub fn else_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![else])
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn suite(&self) -> Option<Suite> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoopVariables {
    pub(crate) syntax: SyntaxNode,
}
impl LoopVariables {
    pub fn primary_expr(&self) -> Option<PrimaryExpr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Expression {
    pub(crate) syntax: SyntaxNode,
}
impl Expression {
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnStmt {
    pub fn return_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![return])
    }
    pub fn expression(&self) -> Option<Expression> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakStmt {
    pub(crate) syntax: SyntaxNode,
}
impl BreakStmt {
    pub fn break_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![break])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ContinueStmt {
    pub fn continue_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![continue])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PassStmt {
    pub(crate) syntax: SyntaxNode,
}
impl PassStmt {
    pub fn pass_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pass])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignStmt {
    pub(crate) syntax: SyntaxNode,
}
impl AssignStmt {
    pub fn expression(&self) -> Option<Expression> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn pluseq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![+=])
    }
    pub fn minuseq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![-=])
    }
    pub fn stareq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*=])
    }
    pub fn slasheq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![/=])
    }
    pub fn slashslasheq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dslash])
    }
    pub fn percenteq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![%=])
    }
    pub fn ampeq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![&=])
    }
    pub fn pipeeq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|=])
    }
    pub fn careteq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![^=])
    }
    pub fn shl_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![<<=])
    }
    pub fn shr_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![>>=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExprStmt {
    pub fn expression(&self) -> Option<Expression> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoadStmt {
    pub(crate) syntax: SyntaxNode,
}
impl LoadStmt {
    pub fn load_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![load])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IfExpr {
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
    pub fn else_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![else])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrimaryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrimaryExpr {
    pub fn operand(&self) -> Option<Operand> {
        support::child(&self.syntax)
    }
    pub fn primary_expr(&self) -> Option<PrimaryExpr> {
        support::child(&self.syntax)
    }
    pub fn dot_suffix(&self) -> Option<DotSuffix> {
        support::child(&self.syntax)
    }
    pub fn call_suffix(&self) -> Option<CallSuffix> {
        support::child(&self.syntax)
    }
    pub fn slice_suffix(&self) -> Option<SliceSuffix> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnaryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl UnaryExpr {
    pub fn plus_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![+])
    }
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn minus_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![-])
    }
    pub fn tilde_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![~])
    }
    pub fn not_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![not])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BinaryExpr {
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn binops(&self) -> AstChildren<Binop> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaExpr {
    pub fn lambda_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![lambda])
    }
    pub fn parameters(&self) -> Option<Parameters> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Operand {
    pub(crate) syntax: SyntaxNode,
}
impl Operand {
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
    pub fn list_expr(&self) -> Option<ListExpr> {
        support::child(&self.syntax)
    }
    pub fn list_comp(&self) -> Option<ListComp> {
        support::child(&self.syntax)
    }
    pub fn dict_expr(&self) -> Option<DictExpr> {
        support::child(&self.syntax)
    }
    pub fn dict_comp(&self) -> Option<DictComp> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expression(&self) -> Option<Expression> {
        support::child(&self.syntax)
    }
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DotSuffix {
    pub(crate) syntax: SyntaxNode,
}
impl DotSuffix {
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallSuffix {
    pub(crate) syntax: SyntaxNode,
}
impl CallSuffix {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn arguments(&self) -> Option<Arguments> {
        support::child(&self.syntax)
    }
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SliceSuffix {
    pub(crate) syntax: SyntaxNode,
}
impl SliceSuffix {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn expression(&self) -> Option<Expression> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ListExpr {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn expression(&self) -> Option<Expression> {
        support::child(&self.syntax)
    }
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListComp {
    pub(crate) syntax: SyntaxNode,
}
impl ListComp {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn comp_clauses(&self) -> AstChildren<CompClause> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DictExpr {
    pub(crate) syntax: SyntaxNode,
}
impl DictExpr {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn entries(&self) -> Option<Entries> {
        support::child(&self.syntax)
    }
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DictComp {
    pub(crate) syntax: SyntaxNode,
}
impl DictComp {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn entry(&self) -> Option<Entry> {
        support::child(&self.syntax)
    }
    pub fn comp_clauses(&self) -> AstChildren<CompClause> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Arguments {
    pub(crate) syntax: SyntaxNode,
}
impl Arguments {
    pub fn argument(&self) -> Option<Argument> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Argument {
    pub(crate) syntax: SyntaxNode,
}
impl Argument {
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
    pub fn starstar_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![**])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompClause {
    pub(crate) syntax: SyntaxNode,
}
impl CompClause {
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn loop_variables(&self) -> Option<LoopVariables> {
        support::child(&self.syntax)
    }
    pub fn in_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![in])
    }
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Entries {
    pub(crate) syntax: SyntaxNode,
}
impl Entries {
    pub fn entry(&self) -> Option<Entry> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Entry {
    pub(crate) syntax: SyntaxNode,
}
impl Entry {
    pub fn test(&self) -> Option<Test> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Binop {
    pub(crate) syntax: SyntaxNode,
}
impl Binop {
    pub fn or_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![or])
    }
    pub fn and_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![and])
    }
    pub fn eqeq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![==])
    }
    pub fn noteq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![!=])
    }
    pub fn l_angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![<])
    }
    pub fn r_angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![>])
    }
    pub fn le_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![<=])
    }
    pub fn ge_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![>=])
    }
    pub fn in_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![in])
    }
    pub fn not_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![not])
    }
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn caret_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![^])
    }
    pub fn amp_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![&])
    }
    pub fn shl_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![<<])
    }
    pub fn shr_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![>>])
    }
    pub fn minus_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![-])
    }
    pub fn plus_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![+])
    }
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
    pub fn percent_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![%])
    }
    pub fn slash_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![/])
    }
    pub fn dslash_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dslash])
    }
}
#[doc = "Enum defs"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Statement {
    DefStmt(DefStmt),
    IfStmt(IfStmt),
    ForStmt(ForStmt),
    SimpleStmt(SimpleStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Test {
    IfExpr(IfExpr),
    PrimaryExpr(PrimaryExpr),
    UnaryExpr(UnaryExpr),
    BinaryExpr(BinaryExpr),
    LambdaExpr(LambdaExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SmallStmt {
    ReturnStmt(ReturnStmt),
    BreakStmt(BreakStmt),
    ContinueStmt(ContinueStmt),
    PassStmt(PassStmt),
    AssignStmt(AssignStmt),
    ExprStmt(ExprStmt),
    LoadStmt(LoadStmt),
}
#[doc = "Any node defs"]
#[doc = "Node boilerplate"]
impl AstNode for File {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FILE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEF_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IfStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IF_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ForStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FOR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SimpleStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SIMPLE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Parameters {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PARAMETERS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Suite {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SUITE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Parameter {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PARAMETER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ElifClauses {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELIF_CLAUSES
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ElseClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELSE_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LoopVariables {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LOOP_VARIABLES
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Expression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPRESSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReturnStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RETURN_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BreakStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BREAK_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ContinueStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONTINUE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PassStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PASS_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssignStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSIGN_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExprStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LoadStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LOAD_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IfExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IF_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrimaryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PRIMARY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UnaryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNARY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BinaryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BINARY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LambdaExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LAMBDA_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Operand {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OPERAND
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DotSuffix {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DOT_SUFFIX
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CallSuffix {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CALL_SUFFIX
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SliceSuffix {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SLICE_SUFFIX
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListComp {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_COMP
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DictExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DICT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DictComp {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DICT_COMP
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Arguments {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARGUMENTS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Argument {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARGUMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMP_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Entries {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENTRIES
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Entry {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENTRY
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Binop {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BINOP
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
#[doc = "Enum boilerplate"]
impl From<DefStmt> for Statement {
    fn from(node: DefStmt) -> Statement {
        Statement::DefStmt(node)
    }
}
impl From<IfStmt> for Statement {
    fn from(node: IfStmt) -> Statement {
        Statement::IfStmt(node)
    }
}
impl From<ForStmt> for Statement {
    fn from(node: ForStmt) -> Statement {
        Statement::ForStmt(node)
    }
}
impl From<SimpleStmt> for Statement {
    fn from(node: SimpleStmt) -> Statement {
        Statement::SimpleStmt(node)
    }
}
impl AstNode for Statement {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, DEF_STMT | IF_STMT | FOR_STMT | SIMPLE_STMT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DEF_STMT => Statement::DefStmt(DefStmt { syntax }),
            IF_STMT => Statement::IfStmt(IfStmt { syntax }),
            FOR_STMT => Statement::ForStmt(ForStmt { syntax }),
            SIMPLE_STMT => Statement::SimpleStmt(SimpleStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Statement::DefStmt(it) => &it.syntax,
            Statement::IfStmt(it) => &it.syntax,
            Statement::ForStmt(it) => &it.syntax,
            Statement::SimpleStmt(it) => &it.syntax,
        }
    }
}
impl From<IfExpr> for Test {
    fn from(node: IfExpr) -> Test {
        Test::IfExpr(node)
    }
}
impl From<PrimaryExpr> for Test {
    fn from(node: PrimaryExpr) -> Test {
        Test::PrimaryExpr(node)
    }
}
impl From<UnaryExpr> for Test {
    fn from(node: UnaryExpr) -> Test {
        Test::UnaryExpr(node)
    }
}
impl From<BinaryExpr> for Test {
    fn from(node: BinaryExpr) -> Test {
        Test::BinaryExpr(node)
    }
}
impl From<LambdaExpr> for Test {
    fn from(node: LambdaExpr) -> Test {
        Test::LambdaExpr(node)
    }
}
impl AstNode for Test {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            IF_EXPR | PRIMARY_EXPR | UNARY_EXPR | BINARY_EXPR | LAMBDA_EXPR
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IF_EXPR => Test::IfExpr(IfExpr { syntax }),
            PRIMARY_EXPR => Test::PrimaryExpr(PrimaryExpr { syntax }),
            UNARY_EXPR => Test::UnaryExpr(UnaryExpr { syntax }),
            BINARY_EXPR => Test::BinaryExpr(BinaryExpr { syntax }),
            LAMBDA_EXPR => Test::LambdaExpr(LambdaExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Test::IfExpr(it) => &it.syntax,
            Test::PrimaryExpr(it) => &it.syntax,
            Test::UnaryExpr(it) => &it.syntax,
            Test::BinaryExpr(it) => &it.syntax,
            Test::LambdaExpr(it) => &it.syntax,
        }
    }
}
impl From<ReturnStmt> for SmallStmt {
    fn from(node: ReturnStmt) -> SmallStmt {
        SmallStmt::ReturnStmt(node)
    }
}
impl From<BreakStmt> for SmallStmt {
    fn from(node: BreakStmt) -> SmallStmt {
        SmallStmt::BreakStmt(node)
    }
}
impl From<ContinueStmt> for SmallStmt {
    fn from(node: ContinueStmt) -> SmallStmt {
        SmallStmt::ContinueStmt(node)
    }
}
impl From<PassStmt> for SmallStmt {
    fn from(node: PassStmt) -> SmallStmt {
        SmallStmt::PassStmt(node)
    }
}
impl From<AssignStmt> for SmallStmt {
    fn from(node: AssignStmt) -> SmallStmt {
        SmallStmt::AssignStmt(node)
    }
}
impl From<ExprStmt> for SmallStmt {
    fn from(node: ExprStmt) -> SmallStmt {
        SmallStmt::ExprStmt(node)
    }
}
impl From<LoadStmt> for SmallStmt {
    fn from(node: LoadStmt) -> SmallStmt {
        SmallStmt::LoadStmt(node)
    }
}
impl AstNode for SmallStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            RETURN_STMT
                | BREAK_STMT
                | CONTINUE_STMT
                | PASS_STMT
                | ASSIGN_STMT
                | EXPR_STMT
                | LOAD_STMT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            RETURN_STMT => SmallStmt::ReturnStmt(ReturnStmt { syntax }),
            BREAK_STMT => SmallStmt::BreakStmt(BreakStmt { syntax }),
            CONTINUE_STMT => SmallStmt::ContinueStmt(ContinueStmt { syntax }),
            PASS_STMT => SmallStmt::PassStmt(PassStmt { syntax }),
            ASSIGN_STMT => SmallStmt::AssignStmt(AssignStmt { syntax }),
            EXPR_STMT => SmallStmt::ExprStmt(ExprStmt { syntax }),
            LOAD_STMT => SmallStmt::LoadStmt(LoadStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            SmallStmt::ReturnStmt(it) => &it.syntax,
            SmallStmt::BreakStmt(it) => &it.syntax,
            SmallStmt::ContinueStmt(it) => &it.syntax,
            SmallStmt::PassStmt(it) => &it.syntax,
            SmallStmt::AssignStmt(it) => &it.syntax,
            SmallStmt::ExprStmt(it) => &it.syntax,
            SmallStmt::LoadStmt(it) => &it.syntax,
        }
    }
}
#[doc = "Any node boilerplate"]
#[doc = "Display impls"]
impl std::fmt::Display for Statement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Test {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SmallStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for File {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SimpleStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Parameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Suite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Parameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElifClauses {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LoopVariables {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BreakStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ContinueStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PassStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LoadStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrimaryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnaryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinaryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Operand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DotSuffix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallSuffix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SliceSuffix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListComp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DictExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DictComp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Arguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Argument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Entries {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Entry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Binop {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
